/**
 * QuantumFlow by eliomatters
 * Quantum-inspired compression algorithm
 */
export { Complex } from './math/Complex';
export { QuantumMath } from './math/QuantumMath';
export { QuantumStateVector } from './models/QuantumStateVector';
export { SuperpositionState, PatternProbability } from './models/SuperpositionState';
export { EntanglementPair } from './models/EntanglementPair';
export { QuantumConfig, QuantumConfigData } from './models/QuantumConfig';
export { CompressedQuantumData, InterferencePattern, QuantumMetadata, CompressionStats } from './models/CompressedQuantumData';
export { QuantumStateConverter, DataPatternAnalysis, ConversionStats } from './core/QuantumStateConverter';
export { QuantumPhaseAssigner, PhaseAssignmentStrategy, PhaseContext, ChunkPhaseInfo } from './core/QuantumPhaseAssigner';
export { DataChunker, ChunkingStrategy, DataChunk, ChunkingAnalysis } from './core/DataChunker';
export { SuperpositionProcessor, ParallelProcessingResult, ProcessingMetrics, DominantPattern, MeasurementResult, ProcessingEfficiency } from './core/SuperpositionProcessor';
export { PatternRecognizer, RecognizedPattern, PatternPosition, ProbabilityAnalysis, DominantProbability, HighProbabilityState, InterferencePattern as PatternInterferencePattern, CompressionEfficiency, OptimizedPattern } from './core/PatternRecognizer';
export { ProbabilityAnalyzer, DistributionAnalysis, DistributionStatistics, ProbabilityCalculation, SignificanceTestResults, CompressionPotentialEstimate, CoherenceAnalysis } from './core/ProbabilityAnalyzer';
//# sourceMappingURL=index.d.ts.map